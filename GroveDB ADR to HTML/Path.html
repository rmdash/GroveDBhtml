<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">ol{margin:0;padding:0}table td,table th{padding:0}.c0{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c1{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c3{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c2{height:11pt}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c3 doc-content"><p class="c1"><span class="c0">&lt;h1 id=&quot;subtree-path-library&quot;&gt;Subtree path library&lt;/h1&gt;</span></p><p class="c1"><span class="c0">&lt;p&gt;Introduction of &lt;code&gt;SubtreePath&lt;/code&gt;, &lt;code&gt;SubtreePathBuilder&lt;/code&gt;, and &lt;code&gt;SubtreePathIter&lt;/code&gt; types for GroveDB&amp;#39;s path</span></p><p class="c1"><span class="c0">management.&lt;/p&gt;</span></p><p class="c1"><span class="c0">&lt;h2 id=&quot;context&quot;&gt;Context&lt;/h2&gt;</span></p><p class="c1"><span class="c0">&lt;p&gt;In our interaction with GroveDB, we consistently provide paths or batches of paths. Previously,</span></p><p class="c1"><span class="c0">managing these paths posed significant challenges due to the lack of a universal way to handle them</span></p><p class="c1"><span class="c0">(generic iterators, slices of slices, slices of vectors), and deriving new paths from existing ones</span></p><p class="c1"><span class="c0">was inefficient and cumbersome.&lt;/p&gt;</span></p><p class="c1"><span class="c0">&lt;h2 id=&quot;decision&quot;&gt;Decision&lt;/h2&gt;</span></p><p class="c1"><span class="c0">&lt;p&gt;To address these issues, we introduced three new constructs: &lt;code&gt;SubtreePath&lt;/code&gt;, &lt;code&gt;SubtreePathBuilder&lt;/code&gt;,</span></p><p class="c1"><span class="c0">and &lt;code&gt;SubtreePathIter&lt;/code&gt;.&lt;/p&gt;</span></p><p class="c1"><span class="c0">&lt;h3 id=&quot;subtreepath&quot;&gt;SubtreePath&lt;/h3&gt;</span></p><p class="c1"><span class="c0">&lt;p&gt;&lt;code&gt;SubtreePath&lt;/code&gt; provides an immutable representation of a path within the GroveDB. It supports efficient</span></p><p class="c1"><span class="c0">derivations - the creation of new paths based on existing ones. As a result, it simplifies the</span></p><p class="c1"><span class="c0">process of creating a path to a subtree and deriving a new path from an existing one, with a change</span></p><p class="c1"><span class="c0">at the end (moving from the path to the path of its parent or descendant).&lt;/p&gt;</span></p><p class="c1"><span class="c0">&lt;p&gt;Takeaway: &lt;code&gt;SubtreePath&lt;/code&gt; holds no path segments and is an immutable view into subtree path.&lt;/p&gt;</span></p><p class="c1"><span class="c0">&lt;h3 id=&quot;subtreepathbuilder&quot;&gt;SubtreePathBuilder&lt;/h3&gt;</span></p><p class="c1"><span class="c0">&lt;p&gt;&lt;code&gt;SubtreePathBuilder&lt;/code&gt; is designed to manage multiple owned path segments at once. It introduces an</span></p><p class="c1"><span class="c0">alternative way of working with paths, offering more local representation of owned path data and is</span></p><p class="c1"><span class="c0">also compatible with &lt;code&gt;SubtreePath&lt;/code&gt; to combine into one path &amp;quot;chain&amp;quot;. That said, a combination of</span></p><p class="c1"><span class="c0">&lt;code&gt;SubtreePath&lt;/code&gt; and &lt;code&gt;SubtreePathBuilder&lt;/code&gt; in any amount and proportion yields a new &lt;code&gt;SubtreePath&lt;/code&gt; with</span></p><p class="c1"><span class="c0">it&amp;#39;s lifetime limited to the last &lt;code&gt;SubtreePathBuilder&lt;/code&gt; (or initial data coming into GroveDB function</span></p><p class="c1"><span class="c0">call).&lt;/p&gt;</span></p><p class="c1"><span class="c0">&lt;h3 id=&quot;subtreepathiter&quot;&gt;SubtreePathIter&lt;/h3&gt;</span></p><p class="c1"><span class="c0">&lt;p&gt;&lt;code&gt;SubtreePathIter&lt;/code&gt; is a reverse iterator over borrowed path segments. It provides consistent results</span></p><p class="c1"><span class="c0">for iterating over paths, regardless of the complexity of path derivations. It works seamlessly with</span></p><p class="c1"><span class="c0">paths created from slices, &lt;code&gt;SubtreePathBuilder&lt;/code&gt; with fully owned data, or a complex mix of derived</span></p><p class="c1"><span class="c0">paths.&lt;/p&gt;</span></p><p class="c1"><span class="c0">&lt;h3 id=&quot;derivation-and-inplace-update-methods&quot;&gt;Derivation and inplace update methods&lt;/h3&gt;</span></p><p class="c1"><span class="c0">&lt;h4 id=&quot;parent-path-derivation&quot;&gt;Parent Path Derivation&lt;/h4&gt;</span></p><p class="c1"><span class="c0">&lt;p&gt;&lt;code&gt;SubtreePath&lt;/code&gt; and &lt;code&gt;SubtreePathBuilder&lt;/code&gt; both provide methods to derive a parent path. These methods</span></p><p class="c1"><span class="c0">return:&lt;/p&gt;</span></p><p class="c1"><span class="c0">&lt;ul&gt;</span></p><p class="c1"><span class="c0">&lt;li&gt;a new &lt;code&gt;SubtreePath&lt;/code&gt; instance representing the parent path that refers to existing data,&lt;/li&gt;</span></p><p class="c1"><span class="c0">&lt;li&gt;a path segment that was the last before derivation.&lt;/li&gt;</span></p><p class="c1"><span class="c0">&lt;/ul&gt;</span></p><p class="c1"><span class="c0">&lt;h4 id=&quot;child-path-derivation&quot;&gt;Child Path Derivation&lt;/h4&gt;</span></p><p class="c1"><span class="c0">&lt;p&gt;&lt;code&gt;SubtreePath&lt;/code&gt; and &lt;code&gt;SubtreePathBuilder&lt;/code&gt; provide methods to derive a path given a child segment. These</span></p><p class="c1"><span class="c0">methods return a new &lt;code&gt;SubtreePathBuilder&lt;/code&gt; instance representing the child path. Child segment could</span></p><p class="c1"><span class="c0">be moved in to builder and this won&amp;#39;t affect it&amp;#39;s lifetime (will be the lifetime of the most</span></p><p class="c1"><span class="c0">&amp;quot;recent&amp;quot; builder in the derivation chain or initially provided data), or if bytes slice is used as</span></p><p class="c1"><span class="c0">path segment a less lifetime will be chosen.&lt;/p&gt;</span></p><p class="c1"><span class="c0">&lt;h4 id=&quot;inplace-update&quot;&gt;Inplace update&lt;/h4&gt;</span></p><p class="c1"><span class="c0">&lt;p&gt;&lt;code&gt;SubtreePathBuilder&lt;/code&gt; provides a &lt;code&gt;push_segment&lt;/code&gt; method to add a custom path segment to the existing</span></p><p class="c1"><span class="c0">path. The same effect could be achieved with subsequent calls to child derivation method, but each</span></p><p class="c1"><span class="c0">segment would act as a node of singly linked list; using &lt;code&gt;push_segment&lt;/code&gt; packs owned data in one</span></p><p class="c1"><span class="c0">place and could be useful when a sequence of path segments is known and about to become a part of</span></p><p class="c1"><span class="c0">subtree path.&lt;/p&gt;</span></p><p class="c1"><span class="c0">&lt;h2 id=&quot;consequences&quot;&gt;Consequences&lt;/h2&gt;</span></p><p class="c1"><span class="c0">&lt;p&gt;By implementing these changes, we&amp;#39;ve enhanced the ergonomics of GroveDB internals with a potential</span></p><p class="c1"><span class="c0">for future optimizations and GroveDB decoupling. The overall change provides a robust and intuitive</span></p><p class="c1"><span class="c0">foundation for path management in GroveDB.&lt;/p&gt;</span></p><p class="c1"><span class="c0">&lt;h2 id=&quot;schema&quot;&gt;Schema&lt;/h2&gt;</span></p><p class="c1"><span class="c0">&lt;p&gt;&lt;img src=&quot;path-schema.png&quot; alt=&quot;schema&quot;&gt;&lt;/p&gt;</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p></body></html>